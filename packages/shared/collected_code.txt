Code Collection Report
Generated: 2024-11-06 12:18:48
Source: /home/jireh/projects/stratpoint/skills-base-platform/packages/shared
Excluded patterns: .git .svn .hg node_modules vendor build dist target __pycache__ *.pyc venv .env .venv *_test.go *.test.js *_spec.rb *Test.java *_test.py .idea .vscode .vs *.swp *.swo *.log *.lock *.tmp docs *.md *.txt
=========================================

File: .eslintrc.js
----------------------------------------

module.exports = {
  parser: '@typescript-eslint/parser',
  parserOptions: {
    project: 'tsconfig.json',
    tsconfigRootDir: __dirname,
    sourceType: 'module',
  },
  plugins: ['@typescript-eslint/eslint-plugin'],
  extends: [
    'plugin:@typescript-eslint/recommended',
    'plugin:prettier/recommended',
  ],
  root: true,
  env: {
    node: true,
    jest: true,
  },
  ignorePatterns: ['.eslintrc.js'],
  rules: {
    '@typescript-eslint/interface-name-prefix': 'off',
    '@typescript-eslint/explicit-function-return-type': 'off',
    '@typescript-eslint/explicit-module-boundary-types': 'off',
    '@typescript-eslint/no-explicit-any': 'off',
  },
};

=========================================

File: src/interfaces/jwt-strategy.interface.ts
----------------------------------------

// packages/shared/src/auth/interfaces/jwt-strategy.interface.ts
export interface IJwtStrategy {
  validate(payload: any): Promise<any>;
}

=========================================

File: src/interfaces/config.interface.ts
----------------------------------------

// src/interfaces/config.interface.ts
export interface IDatabaseConfig {
  uri: string;
  useNewUrlParser: boolean;
  useUnifiedTopology: boolean;
}

export interface IAppConfig {
  port: number;
  environment: string;
}

=========================================

File: src/interfaces/user.interface.ts
----------------------------------------

// src/interfaces/user.interface.ts
import { UserRole } from '../constants/roles.constant';

export interface IUser {
  id: string;
  email: string;
  firstName: string;
  lastName: string;
  roles: UserRole[];
}

=========================================

File: src/guards/roles.guard.ts
----------------------------------------

// src/guards/roles.guard.ts
import { Injectable, CanActivate, ExecutionContext } from '@nestjs/common';
import { Reflector } from '@nestjs/core';
import { UserRole } from '../constants/roles.constant';
import { ROLES_KEY } from '../decorators/roles.decorator';

@Injectable()
export class RolesGuard implements CanActivate {
  constructor(private reflector: Reflector) {}

  canActivate(context: ExecutionContext): boolean {
    const requiredRoles = this.reflector.getAllAndOverride<UserRole[]>(
      ROLES_KEY,
      [context.getHandler(), context.getClass()],
    );
    if (!requiredRoles) {
      return true;
    }
    const { user } = context.switchToHttp().getRequest();
    return requiredRoles.some((role) => user.roles?.includes(role));
  }
}

=========================================

File: src/guards/jwt-auth.guard.ts
----------------------------------------

// src/guards/jwt-auth.guard.ts
import { Injectable, ExecutionContext } from '@nestjs/common';
import { AuthGuard } from '@nestjs/passport';
import { Observable } from 'rxjs';

@Injectable()
export class JwtAuthGuard extends AuthGuard('jwt') {
  canActivate(
    context: ExecutionContext,
  ): boolean | Promise<boolean> | Observable<boolean> {
    // Add custom logic here
    return super.canActivate(context);
  }
}

=========================================

File: src/interceptors/transform.interceptor.ts
----------------------------------------

// src/interceptors/transform.interceptor.ts
import {
  Injectable,
  NestInterceptor,
  ExecutionContext,
  CallHandler,
} from '@nestjs/common';
import { Observable } from 'rxjs';
import { map } from 'rxjs/operators';

@Injectable()
export class TransformInterceptor implements NestInterceptor {
  intercept(context: ExecutionContext, next: CallHandler): Observable<any> {
    return next.handle().pipe(
      map((data) => {
        // If data is already an object and has a data property, return that directly
        if (data && typeof data === 'object' && 'data' in data) {
          return data.data;
        }
        // Otherwise, return the data as is
        return data;
      }),
    );
  }
}

=========================================

File: src/interceptors/validate.interceptor.ts
----------------------------------------

// src/interceptors/validate.interceptor.ts
import {
  Injectable,
  NestInterceptor,
  ExecutionContext,
  CallHandler,
  BadRequestException,
} from '@nestjs/common';
import { Observable } from 'rxjs';
import { plainToClass } from 'class-transformer';
import { validate } from 'class-validator';

@Injectable()
export class ValidateInterceptor implements NestInterceptor {
  constructor(private readonly schema: any) {}

  async intercept(
    context: ExecutionContext,
    next: CallHandler,
  ): Promise<Observable<any>> {
    const request = context.switchToHttp().getRequest();
    const dto = plainToClass(this.schema, request.body);
    const errors = await validate(dto);
    if (errors.length > 0) {
      throw new BadRequestException(errors);
    }
    return next.handle();
  }
}

=========================================

File: src/interceptors/logging.interceptor.ts
----------------------------------------

// src/interceptors/logging.interceptor.ts
import {
  Injectable,
  NestInterceptor,
  ExecutionContext,
  CallHandler,
} from '@nestjs/common';
import { Observable } from 'rxjs';
import { tap } from 'rxjs/operators';

@Injectable()
export class LoggingInterceptor implements NestInterceptor {
  intercept(context: ExecutionContext, next: CallHandler): Observable<any> {
    console.log('Before...');
    const now = Date.now();
    return next
      .handle()
      .pipe(tap(() => console.log(`After... ${Date.now() - now}ms`)));
  }
}

=========================================

File: src/dto/pagination.dto.ts
----------------------------------------

import { IsNumber, IsOptional, Min } from 'class-validator';
import { Type } from 'class-transformer';

export class PaginationDto {
  @IsOptional()
  @IsNumber()
  @Min(1)
  @Type(() => Number)
  page?: number = 1;

  @IsOptional()
  @IsNumber()
  @Min(1)
  @Type(() => Number)
  limit?: number = 10;
}

=========================================

File: src/dto/base.dto.ts
----------------------------------------

// src/dto/base.dto.ts
import { IsOptional, IsDate } from 'class-validator';

export class BaseDto {
  @IsOptional()
  @IsDate()
  createdAt?: Date;

  @IsOptional()
  @IsDate()
  updatedAt?: Date;
}

=========================================

File: src/middlewares/logger.middleware.ts
----------------------------------------

// src/middlewares/logger.middleware.ts
import { Injectable, NestMiddleware, Logger } from '@nestjs/common';
import { Request, Response, NextFunction } from 'express';
import { v4 as uuidv4 } from 'uuid';

@Injectable()
export class LoggerMiddleware implements NestMiddleware {
  private readonly logger = new Logger(LoggerMiddleware.name);

  use(req: Request, res: Response, next: NextFunction) {
    const requestId = uuidv4();
    const startTime = Date.now();

    // Log request details
    this.logger.log({
      message: 'Incoming request',
      requestId,
      method: req.method,
      url: req.originalUrl,
      ip: req.ip,
      userAgent: req.get('User-Agent'),
    });

    // Add requestId to response headers
    res.setHeader('X-Request-ID', requestId);

    // Log response details after the request is processed
    res.on('finish', () => {
      const duration = Date.now() - startTime;
      this.logger.log({
        message: 'Request completed',
        requestId,
        method: req.method,
        url: req.originalUrl,
        statusCode: res.statusCode,
        duration: `${duration}ms`,
      });
    });

    next();
  }
}

=========================================

File: src/entities/base.entity.ts
----------------------------------------

// src/entities/base.entity.ts
import { Prop, Schema } from '@nestjs/mongoose';
import { Document } from 'mongoose';

@Schema()
export class BaseEntity extends Document {
  @Prop({ default: Date.now })
  createdAt: Date;

  @Prop({ default: Date.now })
  updatedAt: Date;
}

=========================================

File: src/base/base.controller.ts
----------------------------------------

// src/base/base.controller.ts
import { Get, Post, Put, Delete, Param, Body, Query } from '@nestjs/common';
import { BaseEntity } from '../entities/base.entity';
import { BaseService } from './base.service';
import { PaginationDto } from '../dto/pagination.dto';

export abstract class BaseController<T extends BaseEntity> {
  constructor(private readonly baseService: BaseService<T>) {}

  @Get()
  async findAll(@Query() paginationDto: PaginationDto) {
    return this.baseService.findAll(paginationDto);
  }

  @Get(':id')
  async findOne(@Param('id') id: string) {
    return this.baseService.findOne(id);
  }

  @Post()
  async create(@Body() createDto: any) {
    return this.baseService.create(createDto);
  }

  @Put(':id')
  async update(@Param('id') id: string, @Body() updateDto: any) {
    return this.baseService.update(id, updateDto);
  }

  @Delete(':id')
  async remove(@Param('id') id: string) {
    return this.baseService.remove(id);
  }
}

=========================================

File: src/base/base.service.ts
----------------------------------------

// src/base/base.service.ts
import { Model, Document } from 'mongoose';
import { NotFoundException } from '@nestjs/common';
import { BaseEntity } from '../entities/base.entity';
import { PaginationDto } from '../dto/pagination.dto';

export abstract class BaseService<T extends BaseEntity> {
  constructor(private readonly model: Model<T & Document>) {}

  async findAll(paginationDto: PaginationDto): Promise<T[]> {
    const { page = 1, limit = 10 } = paginationDto;
    return this.model
      .find()
      .skip((page - 1) * limit)
      .limit(limit)
      .exec() as Promise<T[]>;
  }

  async findOne(id: string): Promise<T> {
    const entity = await this.model.findById(id).exec();
    if (!entity) {
      throw new NotFoundException(`Entity with id ${id} not found`);
    }
    return entity as T;
  }

  async create(createDto: any): Promise<T> {
    const createdEntity = new this.model(createDto);
    return (await createdEntity.save()) as T;
  }

  async update(id: string, updateDto: any): Promise<T> {
    const updatedEntity = await this.model
      .findByIdAndUpdate(id, updateDto, { new: true })
      .exec();
    if (!updatedEntity) {
      throw new NotFoundException(`Entity with id ${id} not found`);
    }
    return updatedEntity as T;
  }

  async remove(id: string): Promise<T> {
    const deletedEntity = await this.model.findByIdAndDelete(id).exec();
    if (!deletedEntity) {
      throw new NotFoundException(`Entity with id ${id} not found`);
    }
    return deletedEntity as T;
  }
}

=========================================

File: src/messaging/messaging.service.ts
----------------------------------------

// src/messaging/messaging.service.ts
import { Injectable } from '@nestjs/common';
import {
  ClientProxy,
  ClientProxyFactory,
  Transport,
} from '@nestjs/microservices';
import { ConfigService } from '@nestjs/config';

@Injectable()
export class MessagingService {
  private client: ClientProxy;

  constructor(private configService: ConfigService) {
    this.client = ClientProxyFactory.create({
      options: {
        urls: [this.configService.get<string>('RABBITMQ_URL') || ''],
        queue: 'main_queue',
      },
      transport: Transport.RMQ,
    });
  }

  async sendMessage(pattern: string, data: any) {
    return this.client.send(pattern, data).toPromise();
  }

  async emit(pattern: string, data: any) {
    this.client.emit(pattern, data);
  }
}

=========================================

File: src/decorators/validate.decorator.ts
----------------------------------------

// src/decorators/validate.decorator.ts
import { applyDecorators, UseInterceptors } from '@nestjs/common';
import { ValidateInterceptor } from '../interceptors/validate.interceptor';

export function Validate(schema: any) {
  return applyDecorators(UseInterceptors(new ValidateInterceptor(schema)));
}

=========================================

File: src/decorators/roles.decorator.ts
----------------------------------------

// src/decorators/roles.decorator.ts
import { SetMetadata } from '@nestjs/common';
import { UserRole } from '../constants/roles.constant';

export const ROLES_KEY = 'roles';
export const Roles = (...roles: UserRole[]) => SetMetadata(ROLES_KEY, roles);

=========================================

File: src/utils/date.util.ts
----------------------------------------

// src/utils/date.util.ts
export function formatDate(date: Date): string {
  return date.toISOString().split('T')[0];
}

export function addDays(date: Date, days: number): Date {
  const result = new Date(date);
  result.setDate(result.getDate() + days);
  return result;
}

=========================================

File: src/utils/validation.util.ts
----------------------------------------

// src/utils/validation.util.ts
export function isValidEmail(email: string): boolean {
  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  return emailRegex.test(email);
}

export function isStrongPassword(password: string): boolean {
  // At least 8 characters, 1 uppercase, 1 lowercase, 1 number, 1 special character
  const passwordRegex =
    /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]{8,}$/;
  return passwordRegex.test(password);
}

=========================================

File: src/strategy/jwt.strategy.ts
----------------------------------------

// packages/user-service/src/auth/jwt.strategy.ts
import { Injectable } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import { PassportStrategy } from '@nestjs/passport';
import { ExtractJwt, Strategy } from 'passport-jwt';
import { JWT_STRATEGY } from '../constants/auth.constants';
import { IJwtStrategy } from '../interfaces/jwt-strategy.interface';

@Injectable()
export class JwtStrategy
  extends PassportStrategy(Strategy, JWT_STRATEGY)
  implements IJwtStrategy
{
  constructor(private configService: ConfigService) {
    super({
      jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),
      ignoreExpiration: false,
      secretOrKey: configService.get<string>('JWT_SECRET'),
    });
  }

  async validate(payload: any) {
    return { userId: payload.sub, email: payload.email, roles: payload.roles };
  }
}

=========================================

File: src/filters/http-exception.filter.ts
----------------------------------------

// src/filters/http-exception.filter.ts
import {
  ExceptionFilter,
  Catch,
  ArgumentsHost,
  HttpException,
} from '@nestjs/common';
import { Request, Response } from 'express';

@Catch(HttpException)
export class HttpExceptionFilter implements ExceptionFilter {
  catch(exception: HttpException, host: ArgumentsHost) {
    const ctx = host.switchToHttp();
    const response = ctx.getResponse<Response>();
    const request = ctx.getRequest<Request>();
    const status = exception.getStatus();

    response.status(status).json({
      statusCode: status,
      timestamp: new Date().toISOString(),
      path: request.url,
      message: exception.message,
    });
  }
}

=========================================

File: src/config/app.config.ts
----------------------------------------

// src/config/app.config.ts
import { registerAs } from '@nestjs/config';

export default registerAs('app', () => ({
  port: process.env.PORT ? parseInt(process.env.PORT, 10) : 3000,
  environment: process.env.NODE_ENV || 'development',
}));

=========================================

File: src/config/database.config.ts
----------------------------------------

// src/config/database.config.ts
import { registerAs } from '@nestjs/config';

export default registerAs('database', () => ({
  uri: process.env.MONGODB_URI || 'mongodb://localhost/skillsbase',
  useNewUrlParser: true,
  useUnifiedTopology: true,
}));

=========================================

File: src/database/database.module.ts
----------------------------------------

// packages/shared/src/database/database.module.ts

import { Module } from '@nestjs/common';
import { ConfigModule, ConfigService } from '@nestjs/config';
import { MongooseModule } from '@nestjs/mongoose';

@Module({
  imports: [
    ConfigModule.forRoot(),
    MongooseModule.forRootAsync({
      imports: [ConfigModule],
      useFactory: async (configService: ConfigService) => ({
        uri: configService.get<string>('MONGODB_URI'),
      }),
      inject: [ConfigService],
    }),
  ],
  exports: [MongooseModule],
})
export class DatabaseModule {}

=========================================

File: src/constants/error-codes.constant.ts
----------------------------------------

// src/constants/error-codes.constant.ts
export enum ErrorCodes {
  VALIDATION_ERROR = 'VALIDATION_ERROR',
  UNAUTHORIZED = 'UNAUTHORIZED',
  NOT_FOUND = 'NOT_FOUND',
  INTERNAL_SERVER_ERROR = 'INTERNAL_SERVER_ERROR',
}

=========================================

File: src/constants/auth.constants.ts
----------------------------------------

export const JWT_STRATEGY = 'jwt';

=========================================

File: src/constants/roles.constant.ts
----------------------------------------

// src/constants/roles.constant.ts
export enum UserRole {
  ADMIN = 'admin',
  USER = 'staff',
  MANAGER = 'manager',
}

=========================================

File: src/logging/middlewares/logger.middleware.ts
----------------------------------------

import { Injectable, NestMiddleware } from '@nestjs/common';
import { NextFunction, Request, Response } from 'express';
import { v4 as uuidv4 } from 'uuid';
import { Logger } from '../logger';
import { Monitor } from '../monitor';

@Injectable()
export class LoggerMiddleware implements NestMiddleware {
  constructor(
    private readonly logger: Logger,
    private readonly monitor: Monitor,
  ) {}

  use(req: Request, res: Response, next: NextFunction) {
    const correlationId =
      req.headers['x-correlation-id']?.toString() || uuidv4();
    const startTime = Date.now();

    // Add correlation ID to request headers
    req.headers['x-correlation-id'] = correlationId;

    this.logger.info('Request started', {
      correlationId,
      method: req.method,
      path: req.url,
      headers: req.headers,
    });

    this.monitor.trackRequest(req, res);

    res.on('finish', () => {
      const duration = Date.now() - startTime;

      this.logger.info('Request completed', {
        correlationId,
        method: req.method,
        path: req.url,
        statusCode: res.statusCode,
        duration,
      });
    });

    next();
  }
}

=========================================

File: src/logging/monitor.ts
----------------------------------------

import { Injectable } from '@nestjs/common';
import { MonitorOptions } from './types';

@Injectable()
export class Monitor {
  private metrics: Map<string, number[]> = new Map();
  private readonly options: Required<MonitorOptions>;

  constructor(
    private readonly service: string,
    options: MonitorOptions = {},
  ) {
    this.options = {
      enabled: true,
      sampleRate: 1,
      metricsInterval: 60000,
      tags: {},
      ...options,
    };

    if (this.options.enabled) {
      this.startMetricsCollection();
    }
  }

  private startMetricsCollection() {
    setInterval(() => {
      this.collectSystemMetrics();
    }, this.options.metricsInterval);
  }

  private collectSystemMetrics() {
    this.trackMetric('memory.usage', process.memoryUsage().heapUsed);
    this.trackMetric('cpu.usage', process.cpuUsage().user);
  }

  trackMetric(name: string, value: number, tags: Record<string, string> = {}) {
    if (!this.options.enabled) return;

    const metricKey = `${name}:${JSON.stringify({ ...this.options.tags, ...tags })}`;
    const currentValues = this.metrics.get(metricKey) || [];
    this.metrics.set(metricKey, [...currentValues, value]);
  }

  startTimer(name: string) {
    const start = process.hrtime();

    return {
      end: () => {
        const [seconds, nanoseconds] = process.hrtime(start);
        const duration = seconds * 1000 + nanoseconds / 1000000;
        this.trackMetric(`${name}.duration`, duration);
        return duration;
      },
    };
  }

  trackRequest(req: any, res: any) {
    const timer = this.startTimer(`http.${req.method}.${req.route.path}`);

    res.on('finish', () => {
      const duration = timer.end();
      this.trackMetric('http.response.status', res.statusCode, {
        method: req.method,
        path: req.route.path,
        status: res.statusCode.toString(),
        duration: `${duration}ms`,
      });
    });
  }

  trackDependency(dependency: string, command: string, duration: number) {
    this.trackMetric(`dependency.${dependency}.duration`, duration, {
      command,
    });
  }
}

=========================================

File: src/logging/module.ts
----------------------------------------

import { DynamicModule, Module } from '@nestjs/common';
import { Logger } from './logger';
import { Monitor } from './monitor';
import { LoggerOptions, MonitorOptions } from './types';

@Module({})
export class LoggingModule {
  static forRoot(
    options: {
      logger?: LoggerOptions;
      monitor?: MonitorOptions;
    } = {},
  ): DynamicModule {
    return {
      module: LoggingModule,
      providers: [
        {
          provide: Logger,
          useValue: new Logger('app', options.logger),
        },
        {
          provide: Monitor,
          useValue: new Monitor('app', options.monitor),
        },
      ],
      exports: [Logger, Monitor],
    };
  }
}

=========================================

File: src/logging/types.ts
----------------------------------------

export enum LogLevel {
  ERROR = 'error',
  WARN = 'warn',
  INFO = 'info',
  DEBUG = 'debug',
}

export interface LogContext {
  service: string;
  timestamp: string;
  correlationId?: string;
  userId?: string;
  traceId?: string;
  [key: string]: any;
}

export interface LoggerOptions {
  level?: LogLevel;
  format?: 'json' | 'text';
  outputs?: ('console' | 'file')[];
  filename?: string;
  maxSize?: number;
  maxFiles?: number;
  sensitiveKeys?: string[];
}

export interface MonitorOptions {
  enabled?: boolean;
  sampleRate?: number;
  metricsInterval?: number;
  tags?: Record<string, string>;
}

=========================================

File: src/logging/utils/security.ts
----------------------------------------

export function maskSensitiveData(data: any, sensitiveKeys: string[]): any {
  if (typeof data !== 'object' || data === null) {
    return data;
  }

  const masked: { [key: string]: any } = Array.isArray(data) ? [] : {};
  for (const [key, value] of Object.entries(data)) {
    if (sensitiveKeys.includes(key.toLowerCase())) {
      masked[key] = '******';
    } else if (typeof value === 'object' && value !== null) {
      masked[key] = maskSensitiveData(value, sensitiveKeys);
    } else {
      masked[key] = value;
    }
  }

  return masked;
}

=========================================

File: src/logging/utils/performance.ts
----------------------------------------

import { Monitor } from '../monitor';

export class PerformanceMonitor {
  private readonly monitor: Monitor;

  constructor(monitor: Monitor) {
    this.monitor = monitor;
  }

  trackDatabaseQuery(query: string, duration: number) {
    this.monitor.trackDependency('database', query, duration);
  }

  trackExternalCall(service: string, method: string, duration: number) {
    this.monitor.trackDependency(service, method, duration);
  }

  trackMemoryUsage() {
    const memory = process.memoryUsage();
    this.monitor.trackMetric('memory.heapUsed', memory.heapUsed);
    this.monitor.trackMetric('memory.heapTotal', memory.heapTotal);
    this.monitor.trackMetric('memory.rss', memory.rss);
  }

  trackCPUUsage() {
    const cpu = process.cpuUsage();
    this.monitor.trackMetric('cpu.user', cpu.user);
    this.monitor.trackMetric('cpu.system', cpu.system);
  }
}

=========================================

File: src/logging/utils/file-writer-factory.ts
----------------------------------------

import { LoggerOptions } from '../types';
import { FileWriterManager } from './file-writer';

export async function writeToFile(
  message: string,
  options: Required<LoggerOptions>,
): Promise<void> {
  try {
    const writer = await FileWriterManager.getWriter({
      filename: options.filename,
      maxSize: options.maxSize,
      maxFiles: options.maxFiles,
      compress: true,
    });

    await writer.write(message);
  } catch (error) {
    console.error('Failed to write to log file:', error);
    // Fallback to console
    console.log(message);
  }
}

=========================================

File: src/logging/utils/formatter.ts
----------------------------------------

export function formatLogMessage(data: any, format: 'json' | 'text'): string {
  if (format === 'json') {
    return JSON.stringify(data);
  }

  const { level, message, context } = data;
  const timestamp = context.timestamp;
  const service = context.service;
  const correlationId = context.correlationId || '';

  return `[${timestamp}] ${level.toUpperCase()} [${service}] ${correlationId} - ${message}`;
}

// src/logging/utils/file-writer.ts
import { promises as fs } from 'fs';
import { LoggerOptions } from '../types';

export async function writeToFile(
  message: string,
  options: Required<LoggerOptions>,
) {
  try {
    const { filename, maxSize, maxFiles } = options;

    // Check file size
    let stats;
    try {
      stats = await fs.stat(filename);
    } catch {
      // File doesn't exist yet
      stats = { size: 0 };
    }

    // Rotate if necessary
    if (stats.size >= maxSize) {
      for (let i = maxFiles - 1; i > 0; i--) {
        try {
          await fs.rename(`${filename}.${i - 1}`, `${filename}.${i}`);
        } catch {
          // File doesn't exist, skip
        }
      }
      try {
        await fs.rename(filename, `${filename}.0`);
      } catch {
        // File doesn't exist, skip
      }
    }

    // Append log
    await fs.appendFile(filename, message + '\n');
  } catch (error) {
    console.error('Failed to write to log file:', error);
  }
}

=========================================

File: src/logging/utils/file-writer.ts
----------------------------------------

import { createReadStream, createWriteStream, promises as fs } from 'fs';
import { dirname } from 'path';
import { pipeline } from 'stream/promises';
import { createGzip } from 'zlib';

export interface FileWriterOptions {
  filename: string;
  maxSize: number;
  maxFiles: number;
  compress?: boolean;
}

export class FileWriter {
  private currentSize: number = 0;
  private writeStream: fs.FileHandle | null = null;
  private readonly options: Required<FileWriterOptions>;
  private locked: boolean = false;

  constructor(options: FileWriterOptions) {
    this.options = {
      compress: true,
      ...options,
    };
  }

  async initialize(): Promise<void> {
    try {
      // Ensure directory exists
      await fs.mkdir(dirname(this.options.filename), { recursive: true });

      // Get current file size if exists
      try {
        const stats = await fs.stat(this.options.filename);
        this.currentSize = stats.size;
      } catch {
        this.currentSize = 0;
      }

      // Open file for appending
      this.writeStream = await fs.open(this.options.filename, 'a');
    } catch (error) {
      console.error('Failed to initialize file writer:', error);
      throw error;
    }
  }

  private async rotateLog(): Promise<void> {
    if (!this.writeStream) {
      return;
    }

    // Close current write stream
    await this.writeStream.close();
    this.writeStream = null;

    // Rotate files
    for (let i = this.options.maxFiles - 1; i >= 0; i--) {
      const currentFile =
        i === 0 ? this.options.filename : `${this.options.filename}.${i}`;
      const nextFile = `${this.options.filename}.${i + 1}`;

      try {
        // Check if current file exists
        await fs.access(currentFile);

        if (i === this.options.maxFiles - 1) {
          // Delete oldest file
          await fs.unlink(currentFile);
        } else if (this.options.compress && i === 0) {
          // Compress the current log file
          await this.compressFile(currentFile, `${nextFile}.gz`);
        } else {
          // Rename file
          await fs.rename(currentFile, nextFile);
        }
      } catch (error) {
        // File doesn't exist, skip
        console.error('File does not exist, skipping...', error);
        continue;
      }
    }

    // Create new file
    this.writeStream = await fs.open(this.options.filename, 'a');
    this.currentSize = 0;
  }

  private async compressFile(
    source: string,
    destination: string,
  ): Promise<void> {
    const gzip = createGzip();
    const sourceStream = createReadStream(source);
    const destinationStream = createWriteStream(destination);

    try {
      await pipeline(sourceStream, gzip, destinationStream);
      await fs.unlink(source); // Delete original file after compression
    } catch (error) {
      console.error('Failed to compress log file:', error);
      throw error;
    }
  }

  async write(message: string): Promise<void> {
    if (!this.writeStream) {
      await this.initialize();
    }

    // Add newline if not present
    const data = message.endsWith('\n') ? message : message + '\n';

    // Wait if another write operation is in progress
    while (this.locked) {
      await new Promise((resolve) => setTimeout(resolve, 10));
    }

    try {
      this.locked = true;

      // Check if rotation is needed
      if (this.currentSize + data.length > this.options.maxSize) {
        await this.rotateLog();
      }

      // Write to file
      await this.writeStream!.write(data);
      this.currentSize += data.length;
    } catch (error) {
      console.error('Failed to write to log file:', error);
      throw error;
    } finally {
      this.locked = false;
    }
  }

  async cleanup(): Promise<void> {
    try {
      if (this.writeStream) {
        await this.writeStream.close();
        this.writeStream = null;
      }
    } catch (error) {
      console.error('Failed to cleanup file writer:', error);
      throw error;
    }
  }
}

// Helper function to handle multiple file writers
export class FileWriterManager {
  private static writers: Map<string, FileWriter> = new Map();

  static async getWriter(options: FileWriterOptions): Promise<FileWriter> {
    const key = `${options.filename}-${options.maxSize}-${options.maxFiles}`;

    if (!this.writers.has(key)) {
      const writer = new FileWriter(options);
      await writer.initialize();
      this.writers.set(key, writer);
    }

    return this.writers.get(key)!;
  }

  static async cleanup(): Promise<void> {
    for (const writer of this.writers.values()) {
      await writer.cleanup();
    }
    this.writers.clear();
  }
}

=========================================

File: src/logging/logger.ts
----------------------------------------

import { Injectable } from '@nestjs/common';
import { LogContext, LoggerOptions, LogLevel } from './types';
import { formatLogMessage, writeToFile } from './utils/formatter';
import { maskSensitiveData } from './utils/security';

@Injectable()
export class Logger {
  private readonly options: Required<LoggerOptions>;

  constructor(
    private readonly service: string,
    options: LoggerOptions = {},
  ) {
    this.options = {
      level: LogLevel.INFO,
      format: 'json',
      outputs: ['console'],
      filename: 'app.log',
      maxSize: 10 * 1024 * 1024, // 10MB
      maxFiles: 5,
      sensitiveKeys: ['password', 'token', 'secret'],
      ...options,
    };
  }

  private shouldLog(level: LogLevel): boolean {
    const levels = Object.values(LogLevel);
    return levels.indexOf(level) <= levels.indexOf(this.options.level);
  }

  private async log(
    level: LogLevel,
    message: string | Error,
    context: Partial<LogContext> = {},
  ) {
    if (!this.shouldLog(level)) {
      return;
    }

    const timestamp = new Date().toISOString();
    const logData = {
      level,
      message: message instanceof Error ? message.message : message,
      stack: message instanceof Error ? message.stack : undefined,
      context: {
        service: this.service,
        timestamp,
        ...context,
      },
    };

    const maskedData = maskSensitiveData(logData, this.options.sensitiveKeys);
    const formattedLog = formatLogMessage(maskedData, this.options.format);

    if (this.options.outputs.includes('console')) {
      console[level](formattedLog);
    }

    if (this.options.outputs.includes('file')) {
      await writeToFile(formattedLog, this.options);
    }
  }

  info(message: string, context?: Partial<LogContext>) {
    return this.log(LogLevel.INFO, message, context);
  }

  error(error: Error | string, context?: Partial<LogContext>) {
    return this.log(LogLevel.ERROR, error, context);
  }

  warn(message: string, context?: Partial<LogContext>) {
    return this.log(LogLevel.WARN, message, context);
  }

  debug(message: string, context?: Partial<LogContext>) {
    return this.log(LogLevel.DEBUG, message, context);
  }
}

=========================================

File: src/index.ts
----------------------------------------

// src/index.ts

export * from './base/base.controller';
export * from './base/base.service';
export * from './config/app.config';
export * from './config/database.config';
export * from './constants/auth.constants';
export * from './constants/error-codes.constant';
export * from './constants/roles.constant';
export * from './database/database.module';
export * from './decorators/roles.decorator';
export * from './decorators/validate.decorator';
export * from './dto/base.dto';
export * from './dto/pagination.dto';
export * from './entities/base.entity';
export * from './filters/http-exception.filter';
export * from './guards/jwt-auth.guard';
export * from './guards/roles.guard';
export * from './interceptors/logging.interceptor';
export * from './interceptors/transform.interceptor';
export * from './interfaces/config.interface';
export * from './interfaces/jwt-strategy.interface';
export * from './interfaces/user.interface';
export * from './messaging/messaging.service';
// export * from './middlewares/logger.middleware';
export * from './strategy/jwt.strategy';
export * from './utils/date.util';
export * from './utils/validation.util';

// logging and monitoring
export * from './logging/middlewares/logger.middleware';
export * from './logging/module';
export * from './logging/monitor';

=========================================

File: test/app.e2e-spec.ts
----------------------------------------


=========================================

Summary
----------------------------------------
Total Files: 40
Total Lines: 1082
Total Size: 30KiB
=========================================
